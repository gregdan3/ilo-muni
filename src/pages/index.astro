---
import Layout from "@layouts/Layout.astro";
import EpochRangePicker from "@components/EpochRangePicker.astro";
import Loader from "@components/Loader.astro";
import Errorer from "@components/Errorer.astro";
import IntDropdown from "@components/IntDropdown.astro";
import CategorizedDropdown from "@components/CategorizedDropdown.astro";
import IconButton from "@components/IconButton.astro";
import InfoModal from "@components/InfoModal.astro";
import Help from "@components/search/Help.mdx";
import { Icon } from "astro-icon/components";

import {
  EARLIEST_YEAR,
  FIELDS,
  LATEST_YEAR,
  SCALES,
  SMOOTHERS,
  SMOOTHINGS,
  UNIT_TIMES,
  defaultScale,
  defaultSmoother,
  defaultSmoothing,
  defaultField,
  defaultUnit,
} from "@utils/constants";

const frontmatter = { title: "ilo Muni" };
---

<script>
  import type {
    Scale,
    Smoother,
    Query,
    Field,
    Params,
    UnitTime,
  } from "@utils/types";
  import { parseInput, hasError } from "@utils/input";
  import { reloadUsageChart } from "@utils/chart";
  import { resolveQuery } from "@utils/sqlite";
  import { getSearchParams, toURLParams } from "@utils/urlparams";
  import { countQuery } from "@utils/analytics";
  import { truncateLabel } from "@utils/other.ts";
  import { FIELDS, SCALES, defaultScale } from "@utils/constants";
  import { randomQuery, copyUrlToClipboard } from "@utils/ui";

  let usageCanvas: HTMLCanvasElement;
  let searchBox: HTMLInputElement;

  let scaleDropdown: HTMLSelectElement;
  let unitDropdown: HTMLSelectElement;
  let fieldDropdown: HTMLSelectElement;
  let smootherDropdown: HTMLSelectElement;
  let smoothingDropdown: HTMLSelectElement;

  let startDropdown: HTMLSelectElement;
  let endDropdown: HTMLSelectElement;

  let loader: HTMLSpanElement;
  let errorer: HTMLSpanElement;
  let errorBin: HTMLDivElement;

  let advancedButton: HTMLElement;
  let sampleQueryButton: HTMLElement;
  let copyUrlButton: HTMLElement;

  let usageForm: HTMLFormElement;

  function initFetch() {
    usageCanvas = document.getElementById("usage")! as HTMLCanvasElement;
    searchBox = document.getElementById("searchBox")! as HTMLInputElement;

    scaleDropdown = document.getElementById(
      "scaleDropdown",
    )! as HTMLSelectElement;
    unitDropdown = document.getElementById(
      "unitDropdown",
    )! as HTMLSelectElement;
    fieldDropdown = document.getElementById(
      "fieldDropdown",
    )! as HTMLSelectElement;
    smootherDropdown = document.getElementById(
      "smootherDropdown",
    )! as HTMLSelectElement;
    smoothingDropdown = document.getElementById(
      "smoothingDropdown",
    )! as HTMLSelectElement;

    startDropdown = document.getElementById(
      "startDropdown",
    )! as HTMLSelectElement;
    endDropdown = document.getElementById("endDropdown")! as HTMLSelectElement;

    loader = document.getElementById("loader")! as HTMLSpanElement;
    errorer = document.getElementById("errorer")! as HTMLSpanElement;
    errorBin = document.getElementById("errorBin")! as HTMLDivElement;

    sampleQueryButton = document.getElementById(
      "sampleQueryButton",
    )! as HTMLElement;
    copyUrlButton = document.getElementById("copyUrlButton")! as HTMLElement;
    advancedButton = document.getElementById("advancedButton")! as HTMLElement;

    usageForm = document.getElementById("usageForm")! as HTMLFormElement;
  }

  function dumpErrors(queries: Query[]) {
    errorBin.innerHTML = "";
    errorBin.textContent = "";

    for (const q of queries) {
      const hasErrors =
        q.errors.length > 0 || q.terms.some((t) => t.errors.length > 0);
      if (!hasErrors) continue;

      // for query
      const ul = document.createElement("ul");

      // query's label
      const headerLi = document.createElement("li");
      headerLi.textContent = truncateLabel(q.raw ?? q.repr) + ":";
      ul.appendChild(headerLi);

      // error container
      const childUl = document.createElement("ul");

      // query-level errs
      for (const err of q.errors) {
        const li = document.createElement("li");
        li.textContent = `${err.message}`;
        childUl.appendChild(li);
      }

      // term-level errors
      for (const t of q.terms) {
        for (const err of t.errors) {
          const li = document.createElement("li");
          const label = truncateLabel(t.raw ?? t.repr);
          li.textContent = `${label}: ${err.message}`;
          childUl.appendChild(li);
        }
      }

      ul.appendChild(childUl);
      errorBin.appendChild(ul);
    }
  }

  function shouldDisableScale(id: Scale | undefined) {
    return id && SCALES[id] && SCALES[id].sums;
  }

  async function updatePage() {
    const queryText = searchBox.value;
    let scale = scaleDropdown.value as Scale;
    const field = fieldDropdown.value as Field;
    const smoother = smootherDropdown.value as Smoother;
    const smoothing = Number(smoothingDropdown.value);

    let start = Number(startDropdown.value);
    let end = Number(endDropdown.value);

    if (end < start) {
      [start, end] = [end, start];
      [startDropdown.value, endDropdown.value] = [
        endDropdown.value,
        startDropdown.value,
      ];
    } else if (end === start) {
      const opts = Array.from(startDropdown.options, (o) => Number(o.value));
      const idx = opts.indexOf(start);

      if (idx < opts.length - 1) {
        // move end to next value
        end = opts[idx + 1];
        endDropdown.value = String(end);
      } else if (idx > 0) {
        start = opts[idx - 1];
        startDropdown.value = String(start);
      }
    }

    const unit = unitDropdown.value as UnitTime;

    const summable = FIELDS[field].summable;
    const options = Array.from(scaleDropdown.querySelectorAll("option"));
    options.forEach((option) => {
      const id = option.id as Scale | undefined;
      if (shouldDisableScale(id)) {
        option.disabled = !summable;
      }
    });
    // bounce user back to default scale
    if (!summable && SCALES[scale].sums) {
      scale = defaultScale;
      scaleDropdown.value = defaultScale;
    }

    if (SCALES[scale].smoothable) {
      smootherDropdown.disabled = false;
      smoothingDropdown.disabled = false;
      // NOTE: do not disable the smoother dropdown when smoothing is 0
      // it's true that it won't do anything, but it feels Terrible UI wise
    } else {
      smootherDropdown.disabled = true;
      smoothingDropdown.disabled = true;
    }

    loader.style.visibility = "visible";
    errorer.style.visibility = "hidden";

    let params: Params = {
      scale,
      field,
      smoother,
      smoothing,
      start,
      end,
      unit,
    };

    let queries: Query[] = [];
    try {
      queries = await updateChart(queryText, params);
      dumpErrors(queries);
    } catch (err) {
      console.error("Couldn't update chart!", err);

      errorBin.innerHTML = "";
      errorBin.textContent = "";
      errorBin.textContent = `Something went wrong! ${err}`;
      errorer.style.visibility = "visible";
    } finally {
      loader.style.visibility = "hidden";
    }

    // valid queries have stable syntax
    let queryReprs = queries.filter((q) => !hasError(q)).map((q) => q.repr);
    // errors are removed
    let query = queryReprs.join(", ");
    // technically wasteful but looks better

    let usedParams: Record<string, string> = {
      query: query,
      scale: scaleDropdown.value,
      field: fieldDropdown.value,
      start: startDropdown.value,
      end: endDropdown.value,
    };

    if (SCALES[scale].smoothable) {
      usedParams.smoothing = smoothingDropdown.value;
      usedParams.smoother = smootherDropdown.value;
    }

    toURLParams(usedParams);

    countQuery();
  }

  async function updateChart(input: string, params: Params): Promise<Query[]> {
    const queries = await parseInput(input);
    const queryResultProms = queries.map((query) =>
      resolveQuery(query, params),
    );
    await Promise.all(queryResultProms);
    const graphable = queries.filter((q) => q.data.length > 0);
    if (graphable.length > 0) {
      await reloadUsageChart(usageCanvas, graphable, params);
    }
    return queries;
  }

  document.addEventListener("DOMContentLoaded", async () => {
    initFetch();

    let initialParams = getSearchParams();
    // aside from query which starts empty, allow defaults of form
    searchBox.value = initialParams.query;
    if (initialParams.field) {
      fieldDropdown.value = initialParams.field;
    }
    if (initialParams.scale) {
      scaleDropdown.value = initialParams.scale;
    }
    if (initialParams.smoothing) {
      smoothingDropdown.value = initialParams.smoothing;
    }
    if (initialParams.smoother) {
      smootherDropdown.value = initialParams.smoother;
    }
    if (initialParams.start) {
      startDropdown.value = initialParams.start;
    }
    if (initialParams.end) {
      endDropdown.value = initialParams.end;
    }
    if (initialParams.unit) {
      unitDropdown.value = initialParams.unit;
    }

    // runs chart updates and such
    await updatePage();

    // setup reactivity
    sampleQueryButton.addEventListener("click", async () => {
      searchBox.value = randomQuery();
      await updatePage();
    });
    copyUrlButton.addEventListener("click", async () => {
      await copyUrlToClipboard();
    });
    advancedButton.addEventListener("click", async () => {
      let state = smootherDropdown.className === "nodisplay";

      if (state) {
        smoothingDropdown.className = "inline";
        smootherDropdown.className = "inline";
      } else {
        smoothingDropdown.className = "nodisplay";
        smootherDropdown.className = "nodisplay";
      }
    });

    usageForm.addEventListener("change", async () => {
      await updatePage();
    });
  });
</script>

<Layout frontmatter={frontmatter}>
  <div>
    <form
      id="usageForm"
      onsubmit="return false;"
      autocomplete="off"
      style="display: inline;"
    >
      <div>
        <input type="text" id="searchBox" spellcheck="false" />
      </div>

      <CategorizedDropdown
        id="scaleDropdown"
        options={SCALES}
        selected={defaultScale}
      />

      <CategorizedDropdown
        id="fieldDropdown"
        options={FIELDS}
        selected={defaultField}
      />

      <CategorizedDropdown
        id="unitDropdown"
        options={UNIT_TIMES}
        selected={defaultUnit}
      />

      <IntDropdown
        id="smoothingDropdown"
        options={SMOOTHINGS}
        selected={defaultSmoothing}
        pluralText=" smoothing"
        style="nodisplay"
      />

      <CategorizedDropdown
        id="smootherDropdown"
        options={SMOOTHERS}
        selected={defaultSmoother}
        style="nodisplay"
      />

      <div></div>

      <EpochRangePicker
        startYear={EARLIEST_YEAR}
        endYear={LATEST_YEAR}
        startValueYear={2016}
        startId="startDropdown"
        endId="endDropdown"
        renderAs="date"
      />
    </form>
    <span style="padding-left: 0.2em"></span>
    <InfoModal>
      <Icon name="mingcute:question-line" slot="button" />
      <Help />
    </InfoModal>
    <IconButton id="advancedButton" icon="mingcute:tool-line" />
    <span style="padding-left: 0.75em"></span>
    <IconButton id="copyUrlButton" icon="mingcute:copy-line" />
    <!-- <IconButton id="copyImageButton" icon="mingcute:pic-line" /> -->
    <!-- <span style="padding-left: 0.75em"></span> -->
    <IconButton id="sampleQueryButton" icon="mingcute:refresh-3-line" />
  </div>

  <div style="position: relative; margin-top: 0.25em;">
    <canvas id="usage" style="width: 100%;  max-height: 70vh;"></canvas>
    <div id="usageLegend" style="margin-top: 0.75em;"></div>
    <div
      style="position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); pointer-events: none;"
    >
      <Loader id="loader" />
      <Errorer id="errorer" />
    </div>
  </div>

  <div id="errorBin"></div>
</Layout>

<style>
  #errorBin {
    font-size: 0.9em;
    line-height: 1.5em;
  }
  #errorBin * {
    padding: 0;
    margin: 0;
  }

  #searchBox {
    width: 65%;
    height: 1.6em;
    font-size: 18px;
    margin-right: 0.4em;
  }

  @media (orientation: portrait) and (pointer: none),
    (orientation: portrait) and (pointer: coarse) {
    #searchBox {
      width: 100%;
    }
  }
</style>
